 /* initialize various flags and other variables */
        memset(visited, 0, (sizeof(short int))*MAXLOC);
        memset(prop, 0, (sizeof(short int))*MAXOBJ);
        memset(&prop[50], 0xff, (sizeof(short int))*(MAXOBJ-50));
        wzdark = closed = closing = holding = detail = 0;
        limit = 100;
        tally = 15;
        tally2 = 0;
        newloc = 1;
        loc = oldloc = oldloc2 = 2;
        knfloc = 0;
        chloc = 114;
        chloc2 = 140;
/*      dloc[DWARFMAX-1] = chloc                                */
        memcpy(dloc, idloc, (sizeof(short int))*DWARFMAX);
        memset(odloc, 0, (sizeof(short int))*DWARFMAX);
        dkill = 0;
        memset(dseen, 0, (sizeof(short int))*DWARFMAX);
        clock1 = 30;
        clock2 = 50;
        panic = 0;
        bonus = 0;
        numdie = 0;
        daltloc = 18;
        lmwarn = 0;
        foobar = 0;
        dflag = 0;
        gaveup = 0;
        saveflg = 0;
        hinttaken = 0;
        hintavail = HINT;
        memset(hintloc, 0, (sizeof(short int)*(MAXHINT+1)));
        testbr = 2;
        return;






  int       turns;
    int       loc,oldloc,oldloc2,newloc;      /* location variables */
    short int cond[MAXLOC];         /* location status      */
    short int place[MAXOBJ];        /* object location      */
    short int fixed[MAXOBJ];        /* second object loc    */
    short int visited[MAXLOC];      /* >0 if has been here  */
    short int prop[MAXOBJ];         /* status of object     */
    int       tally,tally2;         /* item counts          */
    int       limit;                /* time limit           */
    int       lmwarn;               /* lamp warning flag    */
    int       wzdark,closing,closed;/* game state flags     */
    int       holding;              /* count of held items  */
    int       detail;               /* LOOK count           */
    int       knfloc;               /* knife location       */
    int       clock1,clock2,panic;  /* timing variables     */
    short int dloc[DWARFMAX];       /* dwarf locations      */
    int       dflag;                /* dwarf flag           */
    short int dseen[DWARFMAX];      /* dwarf seen flag      */
    short int odloc[DWARFMAX];      /* dwarf old locations  */
    int       daltloc;              /* alternate appearance */
    int       dkill;                /* dwarves killed       */
    int       chloc,chloc2;         /* chest locations      */
    int       bonus;                /* to pass to end       */
    int       numdie;               /* number of deaths     */
    int       object1;              /* to help intrans.     */
    int       gaveup;               /* 1 if he quit early   */
    int       foobar;               /* fie fie foe foo...   */
    int       saveflg;              /* if game being saved  */
    int       dbugflg;              /* if game is in debug  */
    int       hinttaken;            /* minus 1 for each hint */
    int       hintavail;            /* masks of hints still available */
    short int hintloc[MAXHINT+1]; /* moves expended hanging around hint area */








transative verbs


void trverb(void)
{
        switch(verb){
        case CALM:
        case WALK:
        case QUIT:
        case SCORE:
        case FOO:
        case BRIEF:
        case SUSPEND:
        case HOURS:
        case LOG:
                actspk(verb);
                break;
        case TAKE:
                vtake();
                break;
        case DROP:
                vdrop();
                break;
        case OPEN:
        case LOCK:
                vopen();
                break;
        case SAY:
                vsay();
                break;
        case NOTHING:
                rspeak(54);
                break;
        case ON:
                von();
                break;
        case OFF:
                voff();
                break;
        case WAVE:
                vwave();
                break;
        case KILL:
                vkill();
                break;
        case POUR:
                vpour();
                break;
        case EAT:
                veat();
                break;
        case DRINK:
                vdrink();
                break;
        case RUB:
                if (object != LAMP)
                        rspeak(76);
                else
                        actspk(RUB);
                break;
        case THROW:
                vthrow();
                break;
        case FEED:
                vfeed();
                break;
        case FIND:
        case INVENTORY:
                vfind();
                break;
        case FILL:
                vfill();
                break;
        case READ:
                vread();
                break;
        case BLAST:
                vblast();
                break;
        case BREAK:
                vbreak();
                break;
        case WAKE:
                vwake();
                break;
        default:
                printf("This verb is not implemented yet.\n");
        }
}

/*
        CARRY TAKE etc.
*/
void vtake(void)
{
        register int    msg, i;

        if (toting(object)) {
                actspk(verb);
                return;
        }
        /*
         special case objects and fixed objects
        */
        msg = You can't be serious!;
        if (object == PLANT && prop[PLANT] <= 0)
                msg = The plant has exceptionally deep roots and cannot be pulled free.;
        if (object == BEAR && prop[BEAR] == 1)
                msg = The bear is still chained to the wall.;
        if (object == CHAIN && prop[BEAR] != 0)
                msg = The chain is still locked.;
        if (fixed[object]) {
                rspeak(msg);
                return;
        }
        /*
         special case for liquids
        */
        if (object == WATER || object == OIL) {
                if (!here(BOTTLE) || liq() != object) {
                        object = BOTTLE;
                        if (toting(BOTTLE)&&prop[BOTTLE] == 1){
                                vfill();
                                return;
                        }
                        if (prop[BOTTLE] != 1)
                                msg = Your bottle is already full.;
                        if (!toting(BOTTLE))
                                msg = You have nothing in which to carry it.;
                        rspeak(msg);
                        return;
                }
                object = BOTTLE;
        }
        if (holding >= 7) {
                rspeak(92);
                return;
        }
        /*
         special case for bird.
        */
        if (object == BIRD && prop[BIRD] == 0) {
                if (toting(ROD)) {
                        rspeak(The bird was unafraid when you entered, but as you approach it becomes disturbed and you cannot catch it.);
                        return;
                }
                if (!toting(CAGE)) {
                        rspeak(You can catch the bird, but you cannot carry it.);
                        return;
                }
                prop[BIRD] = 1;
        }
        if ( (object == BIRD || object == CAGE) &&
                prop[BIRD] != 0)
                carry((BIRD+CAGE)-object,loc);
        carry(object,loc);
        /*
         handle liquid in bottle
        */
        i = liq();
        if (object == BOTTLE && i != 0)
                place[i] = -1;
        rspeak(54);
}

/*
        DROP etc.
*/
void vdrop(void)
{
        register int    i, msg = 54;

        /*
         check for dynamite
        */
        if (toting(ROD2) && object == ROD && !toting(ROD))
                object = ROD2;
        if (!toting(object)){
                actspk(verb);
                return;
        }
        /*
         snake and bird
        */
        if (object == BIRD && here(SNAKE)) {
                rspeak(30); msg = 0;
                if (closed)
                        dwarfend(136);
                dstroy(SNAKE);
                prop[SNAKE] = -1;
        }
        /*
         coins and vending machine
        */
        else if (object == COINS && here(VEND)) {
                dstroy(COINS);
                drop(BATTERIES,loc);
                pspeak(BATTERIES,0,0);
                return;
        }
        /*
         bird and dragon (ouch!!)
        */
        else if (object == BIRD && at(DRAGON) && prop[DRAGON] == 0){
                rspeak(154); msg = 0;
                dstroy(BIRD);
                prop[BIRD] = 0;
                if (place[SNAKE] != 0)
                        ++tally2;
                return;
        }
        /*
         Bear and troll
        */
        if (object == BEAR && at(TROLL)) {
                rspeak(163); msg = 0;
                move(TROLL,0);
                move((TROLL+MAXOBJ),0);
                move(TROLL2,117);
                move((TROLL2+MAXOBJ),122);
                juggle(CHASM);
                prop[TROLL] = 2;
        }
        /*
         vase
        */
        else if (object == VASE) {
                if (loc == 96)
                        rspeak(54);
                else {
                        prop[VASE] = at(PILLOW) ? 0 : 2;
                        pspeak(VASE,prop[VASE]+1,0);
                        if (prop[VASE] != 0)
                                fixed[VASE] = -1;
                }
                msg = 0;
        }
        /*
         handle liquid and bottle
        */
        i = liq();
        if (i == object)
                object = BOTTLE;
        if (object == BOTTLE && i != 0)
                place[i] = 0;
        /*
         handle bird and cage
        */
        if (object == CAGE && prop[BIRD] != 0)
                drop(BIRD,loc);
        if (object == BIRD)
                prop[BIRD] = 0;
        drop(object,loc);
        rspeak (msg);
}

/*
        LOCK, UNLOCK, OPEN, CLOSE etc.
*/
void vopen(void)
{
        register int    msg,oyclam;

        switch(object) {
        case CLAM:
        case OYSTER:
                oyclam = (object == OYSTER ? 1 : 0);
                if (verb == LOCK)
                        msg = 61;
                else if (!toting(TRIDENT))
                        msg = 122+oyclam;
                else if (toting(object))
                        msg = 120+oyclam;
                else {
                        msg = 124+oyclam;
                        dstroy(CLAM);
                        drop(OYSTER,loc);
                        drop(PEARL,105);
                }
                break;
        case DOOR:
                msg = (prop[DOOR] == 1 ? 54 : 111);
                break;
        case CAGE:
                msg = 32;
                break;
        case KEYS:
                msg = 55;
                break;
        case CHAIN:
                if (!here(KEYS))
                        msg = 31;
                else if (verb == LOCK) {
                        if (prop[CHAIN] != 0)
                                msg = 34;
                        else if (loc != 130)
                                msg = 173;
                        else {
                                prop[CHAIN] = 2;
                                if (toting(CHAIN))
                                        drop(CHAIN,loc);
                                fixed[CHAIN] = -1;
                                msg = 172;
                        }
                }
                else {
                        if (prop[BEAR] == 400)
                                msg = 41;
                        else if (prop[CHAIN] == 0)
                                msg = 37;
                        else {
                                prop[CHAIN] = 0;
                                fixed[CHAIN] = 0;
                                if (prop[BEAR] != 3)
                                        prop[BEAR] = 2;
                                fixed[BEAR] = 2-prop[BEAR];
                                msg = 171;
                        }
                }
                break;
        case GRATE:
                if (!here(KEYS))
                        msg = 31;
                else if (closing) {
                        if (!panic) {
                                clock2 = 15;
                                ++panic;
                        }
                        msg = 130;
                }
                else {
                        msg = 34+prop[GRATE];
                        prop[GRATE] = (verb == LOCK ? 0 : 1);
                        msg += 2*prop[GRATE];
                }
                break;
        default:
                msg = 33;
        }
        rspeak(msg);
}

/*
        SAY etc.
*/
void vsay(void)
{
        int wtype,wval;

        analyze(word1,&wtype,&wval);
        printf("Okay.\n%s\n",wval == SAY ? word2 : word1);
}

/*
        ON etc.
*/
void von(void)
{
        if (!here(LAMP))
                actspk(verb);
        else if (limit<0)
                rspeak(184);
        else {
                prop[LAMP] = 1;
                rspeak(39);
                if (wzdark) {
                        wzdark = 0;
                        describe();
                }
        }
}

/*
        OFF etc.
*/
void voff(void)
{
        if (!here(LAMP))
                actspk(verb);
        else {
                prop[LAMP] = 0;
                rspeak(40);
        }
}

/*
        WAVE etc.
*/
void vwave(void)
{
        if (!toting(object) &&
         (object != ROD || !toting(ROD2)))
                rspeak(29);
        else if (object != ROD || !at(FISSURE) ||
                !toting(object) || closing)
                actspk(verb);
        else {
                prop[FISSURE] = 1-prop[FISSURE];
                pspeak(FISSURE,2-prop[FISSURE],0);
        }
}

/*
        ATTACK, KILL etc.
*/
void vkill(void)
{
        register int    msg, i;

        switch(object) {
        case BIRD:
                if (closed)
                        msg = 137;
                else {
                        dstroy(BIRD);
                        prop[BIRD] = 0;
                        if (place[SNAKE] == 19)
                                ++tally2;
                        msg = 45;
                }
                break;
        case 0:
                msg = 44;
                break;
        case CLAM:
        case OYSTER:
                msg = 150;
                break;
        case SNAKE:
                msg = 46;
                break;
        case DWARF:
                if (closed)
                        dwarfend(136);
                msg = 49;
                break;
        case TROLL:
                msg = 157;
                break;
        case BEAR:
                msg = 165+(prop[BEAR]+1)/2;
                break;
        case DRAGON:
                if (prop[DRAGON] != 0) {
                        msg = 167;
                        break;
                }
                if (!yes(49,0,0))
                        break;
                pspeak(DRAGON,1,0);
                prop[DRAGON] = 2;
                prop[RUG] = 0;
                move((DRAGON+MAXOBJ),-1);
                move((RUG+MAXOBJ),0);
                move(DRAGON,120);
                move(RUG,120);
                for(i = 1;i<MAXOBJ;++i)
                        if (place[i] == 119 || place[i] == 121)
                                move(i,120);
                newloc = 120;
                return;
        default:
                actspk(verb);
                return;
        }
        rspeak(msg);
}

/*
        POUR
*/
void vpour(void)
{
        if (object == BOTTLE || object == 0)
                object = liq();
        if (object == 0) {
                needobj();
                return;
        }
        if (!toting(object)) {
                actspk(verb);
                return;
        }
        if (object != OIL && object != WATER) {
                rspeak(78);
                return;
        }
        prop[BOTTLE] = 1;
        place[object] = 0;
        if (at(PLANT)) {
                if (object != WATER)
                        rspeak(112);
                else {
                        pspeak(PLANT,prop[PLANT]+1,0);
                        prop[PLANT] = (prop[PLANT]+2)%6;
                        prop[PLANT2] = prop[PLANT]/2;
                        describe();
                }
        }
        else if (at(DOOR)) {
                prop[DOOR] = (object == OIL ? 1 : 0);
                rspeak(113+prop[DOOR]);
        }
        else
                rspeak(77);
}

/*
        EAT
*/
void veat(void)
{
        register int    msg;

        switch(object) {
        case FOOD:
                dstroy(FOOD);
                msg = 72;
                break;
        case BIRD: case SNAKE: case CLAM: case OYSTER:
        case DWARF: case DRAGON: case TROLL: case BEAR:
                msg = 71;
                break;
        default:
                actspk(verb);
                return;
        }
        rspeak(msg);
}

/*
        DRINK
*/
void vdrink(void)
{
        if (object != WATER)
                rspeak(110);
        else if (liq() != WATER || !here(BOTTLE))
                actspk(verb);
        else {
                prop[BOTTLE] = 1;
                place[WATER] = 0;
                rspeak(74);
        }
}

/*
        THROW etc.
*/
void vthrow(void)
{
        register int    msg, i;

        if (toting(ROD2) && object == ROD && !toting(ROD))
                object = ROD2;
        if (!toting(object)) {
                actspk(verb);
                return;
        }
        /*
         treasure to troll
        */
        if (at(TROLL) && object >= 50 && object<MAXOBJ) {
                rspeak(159);
                drop(object,0);
                move(TROLL,0);
                move((TROLL+MAXOBJ),0);
                drop(TROLL2,117);
                drop((TROLL2+MAXOBJ),122);
                juggle(CHASM);
                return;
        }
        /*
         feed the bears...
        */
        if (object == FOOD && here(BEAR)) {
                object = BEAR;
                vfeed();
                return;
        }
        /*
         if not axe, same as drop...
        */
        if (object != AXE) {
                vdrop();
                return;
        }
        /*
         AXE is THROWN
        */
        /*
         at a dwarf...
        */
        if (i = dcheck()) {
                msg = 48;
                if (pct(33)) {
                        dseen[i] = dloc[i] = 0;
                        msg = 47;
                        ++dkill;
                        if (dkill == 1)
                                msg = 149;
                }
        }
        /*
         at a dragon...
        */
        else if (at(DRAGON) && prop[DRAGON] == 0)
                msg = 152;
        /*
         at the troll...
        */
        else if (at(TROLL))
                msg = 158;
        /*
         at the bear...
        */
        else if (here(BEAR) && prop[BEAR] == 0) {
                rspeak(164);
                drop(AXE,loc);
                fixed[AXE] = -1;
                prop[AXE] = 1;
                juggle(BEAR);
                return;
        }
        /*
         otherwise it is an attack
        */
        else {
                verb = KILL;
                object = 0;
                itverb();
                return;
        }
        /*
         handle the left over axe...
        */
        rspeak(msg);
        drop(AXE,loc);
        describe();
}

/*
        INVENTORY, FIND etc.
*/
void vfind(void)
{
        register int    msg;
        if (toting(object))
                msg = 24;
        else if (closed)
                msg = 138;
        else if (dcheck() && dflag >= 2 && object == DWARF)
                msg = 94;
        else if (at(object) ||
                (liq() == object && here(BOTTLE)) ||
                object == liqloc(loc))
                msg = 94;
        else {
                actspk(verb);
                return;
        }
        rspeak(msg);
}

/*
        FILL
*/
void vfill(void)
{
        register int    msg, i;

        switch(object) {
        case BOTTLE:
                if (liq() != 0)
                        msg = 105;
                else if (liqloc(loc) == 0)
                        msg = 106;
                else {
                        prop[BOTTLE] = cond[loc] & WATOIL;
                        i = liq();
                        if (toting(BOTTLE))
                                place[i] = -1;
                        msg = (i == OIL ? 108 : 107);
                }
                break;
        case VASE:
                if (liqloc(loc) == 0) {
                        msg = 144;
                        break;
                }
                if (!toting(VASE)) {
                        msg = 29;
                        break;
                }
                rspeak(145);
                vdrop();
                return;
        default:
                msg = 29;
        }
        rspeak(msg);
}

/*
        FEED
*/
void vfeed(void)
{
        register int    msg;

        switch(object) {
        case BIRD:
                msg = 100;
                break;
        case DWARF:
                if (!here(FOOD)) {
                        actspk(verb);
                        return;
                }
                ++dflag;
                msg = 103;
                break;
        case BEAR:
                if (!here(FOOD)) {
                        if (prop[BEAR] == 0)
                                msg = 102;
                        else if (prop[BEAR] == 3)
                                msg = 110;
                        else {
                                actspk(verb);
                                return;
                        }
                break;
                }
                dstroy(FOOD);
                prop[BEAR] = 1;
                fixed[AXE] = 0;
                prop[AXE] = 0;
                msg = 168;
                break;
        case DRAGON:
                msg = (prop[DRAGON] != 0 ? 110 : 102);
                break;
        case TROLL:
                msg = 182;
                break;
        case SNAKE:
                if (closed || !here(BIRD)) {
                        msg = 102;
                        break;
                }
                msg = 101;
                dstroy(BIRD);
                prop[BIRD] = 0;
                ++tally2;
                break;
        default:
                msg = 14;
        }
        rspeak(msg);
}

/*
        READ etc.
*/
void vread(void)
{
        register int    msg;

        msg = 0;
        if (dark()) {
                printf("I see no %s here.\n",probj(object));
                return;
        }
        switch(object) {
        case MAGAZINE:
                msg = 190;
                break;
        case TABLET:
                msg = 196;
                break;
        case MESSAGE:
                msg = 191;
                break;
        case OYSTER:
                if (!toting(OYSTER) || !closed)
                        break;
                if (hintavail&HINTO)
                        if (yes(192,193,54)) {
                            ++hinttaken;
                            hintavail &= ~HINTO;
                        }
                        else;
                else
                    rspeak(194);
                return;
        default:
                ;
        }
        if (msg)
                rspeak(msg);
        else
                actspk(verb);
}

/*
        BLAST etc.
*/
void vblast(void)
{
        if (prop[ROD2] < 0 || !closed)
                actspk(verb);
        else {
                bonus = 133;
                if (loc == 115)
                        bonus = 134;
                if (here(ROD2))
                        bonus = 135;
                rspeak(bonus);
                normend();
        }
}

/*
        BREAK etc.
*/
void vbreak(void)
{
        register int    msg;
        if (object == MIRROR) {
                msg = 148;
                if (closed) {
                        rspeak(197);
                        dwarfend(136);
                }
        }
        else if (object == VASE && prop[VASE] == 0) {
                msg = 198;
                if (toting(VASE))
                        drop(VASE,loc);
                prop[VASE] = 2;
                fixed[VASE] = -1;
        }
        else {
                actspk(verb);
                return;
        }
        rspeak(msg);
}

/*
        WAKE etc.
*/
void vwake(void)
{
        if (object != DWARF || !closed)
                actspk(verb);
        else
                dwarfend(199);
}







intransitive



     switch(verb) {
        case DROP:
        case SAY:
        case WAVE:
        case CALM:
        case RUB:
        case THROW:
        case FIND:
        case FEED:
        case BREAK:
        case WAKE:
                needobj();
                break;
        case TAKE:
                ivtake();
                break;
        case OPEN:
        case LOCK:
                ivopen();
                break;
        case NOTHING:
                rspeak(54);
                break;
        case ON:
        case OFF:
        case POUR:
                trverb();
                break;
        case WALK:
                actspk(verb);
                break;
        case KILL:
                ivkill();
                break;
        case EAT:
                iveat();
                break;
        case DRINK:
                ivdrink();
                break;
        case QUIT:
                ivquit();
                break;
        case FILL:
                ivfill();
                break;
        case BLAST:
                vblast();
                break;
        case SCORE:
                score();
                break;
        case FEE:
        case FIE:
        case FOE:
        case FOO:
        case FUM:
                ivfoo();
                break;
        case SUSPEND:
                saveflg = 1;
                break;
        case READ:
                ivread();
                break;
        case INVENTORY:
                invent();
                break;
        case BRIEF:
                ivbrief();
                break;
        default:
                printf("This intransitive not implemented yet\n");
        }
}

/*
        CARRY, TAKE etc.
*/
void ivtake(void)
{
        register int    anobj,item;

        anobj = 0;
        for(item=1;item<MAXOBJ;++item) {
                if(place[item]==loc) {
                        if(anobj != 0) {
                                needobj();
                                return;
                        }
                        anobj = item;
                }
        }
        if(anobj==0|| (dcheck() && dflag>=2)) {
                needobj();
                return;
        }
        object = anobj;
        vtake();
}

/*
        OPEN, LOCK, UNLOCK
*/
void ivopen(void)
{
        if(here(CLAM))
                object=CLAM;
        if(here(OYSTER))
                object=OYSTER;
        if(at(DOOR))
                object=DOOR;
        if(at(GRATE))
                object=GRATE;
        if(here(CHAIN)) {
                if(object != 0) {
                        needobj();
                        return;
                }
                object=CHAIN;
        }
        if(object==0) {
                rspeak(28);
                return;
        }
        vopen();
}

/*
        ATTACK, KILL etc
*/
void ivkill(void)
{
        object1 = 0;
        if(dcheck() && dflag >=2)
                object=DWARF;
        if(here(SNAKE))
                addobj(SNAKE);
        if(at(DRAGON) && prop[DRAGON]==0)
                addobj(DRAGON);
        if(at(TROLL))
                addobj(TROLL);
        if(here(BEAR) && prop[BEAR]==0)
                addobj(BEAR);
        if(object1 != 0) {
                needobj();
                return;
        }
        if(object != 0) {
                vkill();
                return;
        }
        if(here(BIRD) && verb!= THROW)
                object=BIRD;
        if(here(CLAM) || here(OYSTER))
                addobj(CLAM);
        if(object1 != 0) {
                needobj();
                return;
        }
        vkill();
}

/*
        EAT
*/
void iveat(void)
{
        if(!here(FOOD))
                needobj();
        else {
                object=FOOD;
                veat();
        }
}

/*
        DRINK
*/
void ivdrink(void)
{
        if(liqloc(loc) != WATER &&
         (liq()!= WATER || !here(BOTTLE)))
                needobj();
        else {
                object=WATER;
                vdrink();
        }
}

/*
        QUIT
*/
void ivquit(void)
{
        if(gaveup=yes(22,0,54))
                normend();
}

/*
        FILL
*/
void ivfill(void)
{
        if(!here(BOTTLE))
                needobj();
        else {
                object=BOTTLE;
                vfill();
        }
}

/*
        Handle fee fie foe foo...
*/
void ivfoo(void)
{
        register int    k,msg;
        k = verb - FEE + 1;
        msg = 42;
        if (foobar != 1-k) {
                if (foobar != 0)
                        msg = 151;
                rspeak(msg);
                return;
        }
        foobar = k;
        if (k != 4)
                return;
        foobar = 0;
        if (place[EGGS] == 92 ||
         (toting(EGGS) && loc == 92)) {
                rspeak(msg);
                return;
        }
        if (place[EGGS] == 0 && place[TROLL] == 0 &&
         prop[TROLL] == 0)
                prop[TROLL] = 1;
        if (here(EGGS))
                k = 1;
        else if (loc == 92)
                k = 0;
        else
                k = 2;
        move(EGGS,92);
        pspeak(EGGS,k,0);
        return;
}

/*
        read etc...
*/
void ivread(void)
{
        if (here(MAGAZINE))
                object = MAGAZINE;
        if (here(TABLET))
                object = object*100 + TABLET;
        if (here(MESSAGE))
                object = object*100 + MESSAGE;
        if (object > 100 || object == 0 || dark()) {
                needobj();
                return;
        }
        vread();
}

/*
        INVENTORY
*/
void invent(void)
{
        register int    msg, i;

        msg = 98;
        for (i=1; i<=MAXOBJ; ++i) {
                if (i==BEAR || !toting(i))
                        continue;
                if (msg)
                        rspeak(99);
                msg = 0;
                pspeak(i,-1,0);
        }
        if (toting(BEAR))
                msg = 141;
        if (msg)
                rspeak(msg);
}

/*
        ensure uniqueness as objects are searched
        out for an intransitive verb
*/
void addobj(register int obj)
{
        if(object1 != 0)
                return;
        if(object != 0) {
                object1 = -1;
                return;
        }
        object = obj;
}
/*
        turn on brief switch
*/
void ivbrief(void)
{
        detail |= 2;
        actspk(verb);
}













turn


    register int    i;
        /*
                if closing, then he can't leave except via
                the main office.
        */
        if (newloc < 9 && newloc != 0 && closing) {
                rspeak(130);
                newloc = loc;
                if (!panic)
                        clock2 = 15;
                panic = 1;
        }
        /*
                see if a dwarf has seen him and has come
                from where he wants to go.
        */
        if (newloc != loc && !forced(loc) && (cond[loc]&NOPIRAT) == 0)
                for (i = 1; i< (DWARFMAX-1); ++i)
                        if (odloc[i] == newloc && dseen[i]) {
                                newloc = loc;
                                rspeak(2);
                                break;
                        }

        dwarves();      /* & special dwarf(pirate who steals)   */

        /* added by BDS C conversion */
        if (loc != newloc) {
                if (loc == 0) visited[newloc] = (visited[newloc]+3) & ~3;
                ++turns;
                loc = newloc;

        /* check for death */
        if (loc == 0) {
                death();
                return;
        }

        /* check for forced move */
        if (forced (loc)) {
                describe();
                domove();
                return;
        }

        /* check for wandering in dark */
        if (wzdark && dark() && pct(35)) {
                rspeak(23);
                oldloc2 = loc;
                death();
                return;
        }

        /* describe his situation */
        describe();
        if (!dark ())
                ++visited[loc];
        }                               /* if (loc != newloc)   */

        if (closed) {
                if (prop[OYSTER] < 0 && toting (OYSTER))
                        pspeak(OYSTER, 1, 0);
                for (i = 1; i <= MAXOBJ; ++i)
                        if (toting (i) && prop[i] < 0)
                                prop[i] = -1-prop[i];
        }

        wzdark = dark();
        if (knfloc > 0 && knfloc != loc)
                knfloc = 0;

        if (stimer())   /* as the grains of sand slip by        */
                return;

        if (cond[loc]&hintavail)
            switch (cond[loc]&HINT) {
                case HINTF:
                    ++hintloc[HINTAREAF];
                    if (hintloc[HINTAREAF]>20 && visited[8]==0 /* never in yet */)
                        tryhint (56, HINTF, HINTAREAF);
                    break;
                case HINTC:
                    ++hintloc[HINTAREAC];
                    if (hintloc[HINTAREAC]>3 && prop[GRATE]==0 && !toting(KEYS))
                        tryhint (62, HINTC, HINTAREAC);
                    break;
                case HINTB:
                    ++hintloc[HINTAREAB];
                    if (hintloc[HINTAREAB]>4 && place[BIRD]==loc && toting(ROD))
                        tryhint (18, HINTB, HINTAREAB);
                    break;
                case HINTS:
                    ++hintloc[HINTAREAS];
                    if (hintloc[HINTAREAS]>5 && place[SNAKE]==loc && !toting(BIRD))
                        tryhint (20, HINTS, HINTAREAS);
                    break;
                case HINTM:
                    ++hintloc[HINTAREAM];
                    if (hintloc[HINTAREAM]>15)
                        tryhint (176, HINTM, HINTAREAM);
                    break;
                case HINTP:
                    ++hintloc[HINTAREAP];
                    if (hintloc[HINTAREAP]>5 && place[EMERALD]!=100)
                        tryhint (178, HINTP, HINTAREAP);
                    break;
                case HINTW:
                    ++hintloc[HINTAREAW];
                    if (hintloc[HINTAREAW]>15)
                        tryhint (180, HINTW, HINTAREAW);
            }
        else
            memset(hintloc, 0, (sizeof(int)*(MAXHINT+1)));


        while (!english())      /* retrieve player instructions */
                ;

#if ! defined(NDEBUG)
        if (dbugflg)
                printf("loc = %d, verb = %d, object = %d, motion = %d\n",
                       loc, verb, object, motion);
#endif

        if (motion)             /* execute player instructions  */
                domove();
        else if (object)
                doobj();
        else
                itverb();
}

/*
        Routine to describe current location
*/
void describe(void)
{
        if (toting(BEAR))
                rspeak(141);
        if (dark())
                rspeak(16);
        else {
            if ((visited[loc] & 3) || ((detail & testbr) && visited[loc]))
                    descsh(loc);
            else
                    desclg(loc);
            if (!dark())
                descitem();
        }
        if (loc == 33 && pct(25) && !closing)
                rspeak(8);
}

/*
        Routine to describe visible items
*/
void descitem(void)
{
        register int    i, init = 0;
        int             state, prespace;

        for (i = 1;i<MAXOBJ; ++i) {
                if (at(i)) {
                        if (i == STEPS && toting(NUGGET))
                                continue;
                        if (prop[i]<0) {
                                if (closed)
                                        continue;
                                else {
                                        prop[i] = 0;
                                        if (i == RUG || i == CHAIN)
                                                ++prop[i];
                                        --tally;
                                }
                        }
                        if (i == STEPS && loc == fixed[STEPS])
                                state = 1;
                        else
                                state = prop[i];
                        if (!init && !(detail & 2)) {
                                init = 1;
                                prespace = 1;
                        }
                        else
                                prespace = 0;
                        pspeak(i, state, prespace);
                }
        }
        if (tally == tally2 && tally != 0 && limit > 35)
                limit = 35;
}

/*
        Routine to handle motion requests
*/
void domove(void)
{
        gettrav(loc);
        switch(motion) {
        case NULLX:
                break;
        case BACK:
                goback();
                break;
        case LOOK:
                if (!detail) {
                        rspeak(15);
                        detail |= 1;
                }
                wzdark = 0;
                visited[loc] = (visited[loc]+3) & ~3;
                testbr = 0;
                newloc = loc;
                loc = 0;
                break;
        case CAVE:
                if (loc<8)
                        rspeak(57);
                else
                        rspeak(58);
                break;
        default:
                oldloc2 = oldloc;
                oldloc = loc;
                dotrav();
        }
}

/*
        Routine to handle request to return
        from whence we came!
*/
void goback(void)
{
        register int    kk, k2;
        int             want, temp;
        struct trav strav[MAXTRAV];

        if (forced(oldloc))
                want = oldloc2;
        else
                want = oldloc;
        oldloc2 = oldloc;
        oldloc = loc;
        k2 = 0;
        if (want == loc) {
                rspeak(91);
                return;
        }
        copytrv(travel, strav);
        for (kk = 0; travel[kk].tdest != -1; ++kk) {
                if (!travel[kk].tcond && travel[kk].tdest == want) {
                        motion = travel[kk].tverb;
                        dotrav();
                        return;
                }
                if (!travel[kk].tcond) {
                        k2 = kk;
                        temp = travel[kk].tdest;
                        if (temp <= MAXLOC) {
                                gettrav(temp);
                                if (forced(temp) && travel[0].tdest == want)
                                        k2 = temp;
                                copytrv(strav, travel);
                        }
                        else
                                k2 = 0;
                }
        }
        if (k2) {
                motion = travel[k2].tverb;
                dotrav();
        }
        else
                rspeak(140);
}



score

   register int t, s;
        s = t = 0;
        {
                register int i, k;
                for (i = 50; i<=MAXTRS; ++i) {
                        if (i == CHEST)
                                k = 14;
                        else if (i > CHEST)
                                k = 16;
                        else
                                k = 12;
                        if (prop[i] >= 0)
                                t += 2;
                        if (place[i] == 3 && prop[i] == 0)
                                t += k-2;
                }
        }
        printf("%-22s%4d\n", "Treasures:", s = t);
        t = (MAXDIE - numdie)*10;
        if (t)
                printf("%-22s%4d\n", "Survival:", t);
        s += t;
        if (!gaveup)
                s += 4;
        t = visited[19] ? 25 : 0;
        if (t)
                printf("%-22s%4d\n", "Getting well in:", t);
        s += t;
        t = closing ? 25 : 0;
        if (t)
                printf("%-22s%4d\n", "Masters section:", t);
        s += t;
        if (closed) {
                if (bonus == 0)
                        t = 10;
                else if (bonus == 135)
                        t = 25;
                else if (bonus == 134)
                        t = 30;
                else if (bonus == 133)
                        t = 45;
                printf("%-22s%4d\n", "Bonus:", t);
                s += t;
        }
        if (place[MAGAZINE] == 108)
                s += 1;
        t = -15 * hinttaken;
        if (t) {
                printf("%-22s%4d\n", "Hints & intructions:", t);
                s += t;
        }
        s += 2;
        if (s < 0) s = 0;
        printf("%-22s%4d\n", "Score:", s);
        return s;




